# -- ПРИНЦИП РАБОТЫ --

# Сортировка таблицы результатов участников соревнования выполняется
# по алгоритму Хоара (quick sort) без использования дополнительной
# памяти, то есть массив сортируется in-place. Для возможности
# непосредственного сравнения результатов отдельных участников между
# собой запись с результатом перед считыванием в оперативную память
# трансформируется в вид [-P, F, login]. В качестве опорного элемента
# выбирается крайний правый.


# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

# По условию задачи требуется реализовать алгоритм быстрой сортировки
# (англ. quick sort) для таблицы результатов без использования
# дополнительной памяти для промежуточных данных (такая модификация
# быстрой сортировки называется 'in-place'). Идея алгоритма на основе
# предоставленного в задаче описания. Ссылка на объект массива не
# изменяется в процессе сортировки, дополнительные объекты не
# создаются.


# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --

# Сложность в худшем случае O(n2). Требуется принимать во внимание
# сложность в худшем, в среднем и в лучших случаях. Особенность
# быстрой сортировки в том, что сложность быстрой сортировки в среднем
# такая же, как в лучшем случае: O(nlog⁡n). Сложность в среднем
# показывает то, как работает алгоритм на практике, то есть O(nlogn).
# Учитывая время на чтение массива для вывода результатов программа
# выполняется в сумме за O(nlogn + n), то есть за O(nlogn).


# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

# Чтобы хранить локальные переменные и адрес возврата на каждом уровне
# рекурсии, потребуется O(d) памяти на стеке, где d — глубина
# рекурсии. В быстрой сортировке глубина рекурсии равна logn, поэтому
# этот метод расходует O(logn) памяти на стеке.


# https://contest.yandex.ru/contest/23815/run-report/70752179/
from typing import List


def partition(arr: List, left: int, right: int) -> tuple:
    pivot = arr[right]
    while left < right:
        if arr[left] < pivot:
            left += 1
        if pivot < arr[right]:
            right -= 1
        if pivot < arr[left] or arr[right] < pivot:
            arr[left], arr[right] = arr[right], arr[left]
    return left - 1, right + 1


def quicksort(arr: List, left: int, right: int) -> None:
    if right - left <= 0:
        return
    part_left, part_right = partition(arr, left, right)
    quicksort(arr, left, part_left)
    quicksort(arr, part_right, right)


def main() -> int:
    n = int(input())
    results = []
    for _ in range(n):
        x = input().split()
        results.append([-int(x[1]), int(x[2]), x[0]])
    quicksort(results, 0, len(results) - 1)
    [print(x[2]) for x in results]
    return 0


if __name__ == '__main__':
    main()
