# -- ПРИНЦИП РАБОТЫ --

# В первую очередь требуется отыскать минимальный элемент массива.
# Начиная с центрального элемента массива будем искать бинарным поиском
# тот элемент, у которого соседний слева больше. Если условие
# справедливо для центрального элемента, то вернуть центральный элемент.
# Если последний элемент массива больше центрального, то продолжить
# рекурсивно искать в левой части, иначе в правой части.

# Индекс минимального элемента указывает на сдвиг относительно
# отсортированного массива, что можно использовать для бинарного
# поиска искомого элемента представив массив отсортированным и
# конвертируя индекс центрального элемента в нумерацию сломанного
# массива для сравнения с искомым.


# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

# По условию задачи требуется реализовать функцию, осуществляющую поиск
# в сломанном массиве. Важно увидеть, что массив является
# отсортированным, но имеет сдвиг, так как изначально был получен из
# кольцевого буфера. Поэтому с учетом сдвига задача сводится к
# обыкновенному бинарному поиску.


# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --

# Бинарный поиск минимального элемента отнимает O(logn). Бинарный поиск
# искомого элемента отнимает O(logn). В сумме решение работает за
# O(logn).


# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

# Чтобы хранить локальные переменные и адрес возврата на каждом уровне
# рекурсии, потребуется O(d) памяти на стеке, где d — глубина рекурсии.
# В бинарном поиске глубина рекурсии равна logn, поэтому этот метод расходует
# O(logn) памяти на стеке.


# https://contest.yandex.ru/contest/23815/run-report/69690342/
from typing import List


def get_shift(arr: List[int], left: int, right: int) -> int:
    if left == right:
        return 0
    mid = (left + right) // 2
    if arr[mid] < arr[mid - 1]:
        return mid
    elif arr[mid] < arr[len(arr) - 1]:
        return get_shift(arr, left, mid)
    else:
        return get_shift(arr, mid+1, right)


def get_idx(arr: List[int], x: int, left: int, right: int, shift: int) -> int:
    if right <= left:
        return -1
    mid = (left + right) // 2
    idx = mid + shift if mid + shift < len(arr) else mid + shift - len(arr)
    if x == arr[idx]:
        return idx
    elif x < arr[idx]:
        return get_idx(arr, x, left, mid, shift)
    else:
        return get_idx(arr, x, mid+1, right, shift)


def broken_search(nums: List[int], target: int) -> int:
    return get_idx(nums, target, 0, len(nums), get_shift(nums, 0, len(nums)))


def main() -> int:
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
    return 0


if __name__ == '__main__':
    main()
