# -- ПРИНЦИП РАБОТЫ --

# Поступающие на вход запакованные строки (ЗС) распаковываются, при
# этом отдельно вычисляются и сохраняются минимальная и максимальная
# строки среди всех распакованных строк отсортированных в
# лексикографическом порядке. При этом всё множество распакованных
# строк не хранится в памяти. Задача поиска наибольшего общего
# префикса (НОП) всех строк сводится к поиску НОП минимальной и
# максимальной строк.


# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

# 1. ЗС распаковывается рекурсивно.

# Строка, состоящая только из строчных букв английского алфавита
# является ЗС, поэтому если ЗС D имеет вид D=AB, где A и B тоже ЗС, то
# f(D) = f(A) + f(B), то есть последовательность только из строчных
# букв копируется в распакованную строку без изменений.

# Если же D=n[A], то f(D) = f(A) × n, где n — однозначное натуральное
# число, то, если в ЗС встретилась цифра, тогда за цифрой
# гарантировано следует открывающая квадратная скобка. Подстрока ЗС,
# следующая за открывающей квадратной скобкой, подается на вход
# рекурсивному вызову функции. Базовым случаем рекурсии является
# символ закрывающей квадратной скобки, функция возвращает количество
# символов ЗС и эту ЗС в распакованном виде. Когда в функцию передана
# строка без закрывающей квадратной скобки, базовым случаем является
# проход по всем символам ЗС. Количество символов ЗС, возвращаемое
# функцией, используется для сдвига указателя на символ после D.

# 2. Поиск НОП.

# НОП содержится в каждой из строк по определению. Представим
# множество строк отсортированных в лексикографическом порядке. НОП
# минимальной и максимальной строк будет соответствовать НОП всех
# строк, так как при лексикографической сортировке первоприоритетно
# сравниваются символы строки начиная с первого, отсутствующий символ
# меньше любого символа. Префикс также рассматривается с первого
# символа строки.


# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --

# O(n), где n - длина наибольшей распакованной строки.


# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

# O(n), где n - длина наибольшей распакованной строки, а также O(d)
# памяти на стеке, где d - максимальная глубина вложенности ЗС.


# https://contest.yandex.ru/contest/26133/run-report/75106505/
from typing import List


def unpack(s: str, unpacked: List[str]) -> int:
    i = 0
    while i < len(s):
        x = s[i]
        if x.isdigit():
            unpacked_bracket = []
            i += 2 + unpack(s[i + 2 :], unpacked_bracket)
            unpacked.append(''.join(unpacked_bracket) * int(x))
        elif x == ']':
            return i
        else:
            unpacked.append(x)
        i += 1
    return i


def find_longest_common_prefix(n: int) -> None:
    cur_min, cur_max = '', ''
    for _ in range(n):
        unpacked = []
        unpack(input(), unpacked)
        s = ''.join(unpacked)
        if not len(cur_min):
            cur_min, cur_max = s, s
        elif cur_min > s:
            cur_min = s
        elif cur_max < s:
            cur_max = s
    prefix = ''
    for i in range(len(cur_min)):
        if cur_min[i] == cur_max[i]:
            prefix += cur_min[i]
        else:
            break
    print(prefix)


def main() -> int:
    find_longest_common_prefix(int(input()))
    return 0


if __name__ == '__main__':
    main()
