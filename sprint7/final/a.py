# -- ПРИНЦИП РАБОТЫ --

# Поиск расстояния Левенштейна выполняется методом динамического
# программирования Вагнера - Фишера.

# 1. В массиве dp размером n на m, где n и m - длины строк s и t,
# соответственно, хранится расстояние dp[i][j] между префиксами строк
# s и t, длины которых равны, соответственно, i и j, то есть dp[i][j]
# = d(s(1,i), t(1,j)).

# 2. Базовыми случаями являются: dp[0][0] = 0, в первом столбце
# dp[i][0] количество удалений первых i символов s, в первой строке
# dp[0][j] количество вставок первых j символов t.

# 3. Цену преобразования символа a в символ b обозначим через w(a,b).
# Таким образом, w(a,b) – это цена замены одного символа на другой,
# когда a≠b, w(a,ε) – цена удаления a, а w(ε, b) – цена вставки b. В
# случае, когда выполнены условия

#     w(a,ε) = 1
#     w(ε,b) = 1
#     w(a,b) = 1, если a≠b,
#     w(a,b) = 0, если a=b

# d является расстоянием Левенштейна:
# dᵢ,ⱼ = min{dᵢ₋₁,ⱼ + w(sᵢ,ε), dᵢ,ⱼ₋₁ + w(ε,tⱼ), dᵢ₋₁,ⱼ₋₁ + w(sᵢ,tⱼ)}

# 4. Чтобы посчитать значение в клетке dp[i][j], нужно знать значение
# в dp[i-1][j], в dp[i-1][j-1] и dp[i][j-1]. Это получится, если
# обходить матрицу сначала по строкам, потом по столбцам.

# 5. Искомое значение будет содержаться в ячейке dp[n][m], то есть в
# нижней правой клетке матрицы.


# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

# Если известна цена преобразования s(1,i-1) в t(1,j), то цену
# преобразования s(1,i) в t(1,j) мы получим, добавив к ней цену
# удаления sᵢ. Аналогично, цену преобразования s(1,i) в t(1,j) можно
# получить, прибавив цену вставки tⱼ к цене преобразования s(1,i) в
# t(1,j-1). Наконец, зная цену преобразования s(1,i-1) в t(1,j-1),
# цену преобразования s(1,i) в t(1,j) мы получим, прибавив к ней цену
# замены sᵢ на tⱼ. Требуется брать минимальную стоимость для
# перечисленных атомарных изменений.


# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --

# Основной цикл повторяется n * m раз. Таким образом, временная
# сложность алгоритма O(nm).


# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --

# Для хранения полной матрицы расстояний требуется O(nm) памяти, но
# для расчета необходимы только текущая и предыдущая строки. Программа
# хранит только текущую и предыдущую строки, при этом строки матрицы
# предназначены для более короткой строки символов. Таким образом
# потребление памяти снижено до O(m), где m - длина более короткой
# строки.


# https://contest.yandex.ru/contest/25597/run-report/73605302/
def find_Levenshtein_dist(s: str, t: str) -> None:
    if len(s) < len(t):
        s, t = t, s
    n, m = len(s), len(t)

    dp_curr = [*range(m + 1)]
    for i in range(1, n + 1):
        dp_prev, dp_curr = dp_curr, [i] + [0] * m
        for j in range(1, m + 1):
            update, delete, insert = (
                dp_prev[j - 1],
                dp_prev[j] + 1,
                dp_curr[j - 1] + 1,
            )
            if s[i - 1] != t[j - 1]:
                update += 1
            dp_curr[j] = min(update, delete, insert)
    print(dp_curr[m])


def main() -> int:
    find_Levenshtein_dist(input(), input())
    return 0


if __name__ == '__main__':
    main()
